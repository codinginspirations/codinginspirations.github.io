{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/my-third-post","webpackCompilationHash":"96025279296d5e222e0b","result":{"data":{"markdownRemark":{"html":"<p><strong>This is a two part series blog post, <a href=\"/blog/my-first-post\">here is the second part</a>.</strong></p>\n<p>If you're looking to launch a small, static, and speedy website, micro-site, or landing page, you may be considering a static-site generator like Gatsby.</p>\n<p>This article will walk you through the process of using Gatsby alongside dotCMS, a Java-based open-source headless CMS, to build a static website that uses API calls to pull content that's created, stored, and managed in dotCMS, and presented by Gatsby.</p>\n<h2>What You Need:</h2>\n<ol>\n<li><a href=\"https://nodejs.org/en/\">Node.js and NPM</a></li>\n<li><a href=\"https://reactjs.org/\">React.js</a> knowledge</li>\n<li><a href=\"https://graphql.org/\">GraphQL</a> knowledge (not required but you are going to use it. You can copy + paste)</li>\n</ol>\n<h2>What is Gatsby?</h2>\n<p>Gatsby defines themselves as \"a blazing fast modern site generator for React\" and yes, the generated sites are fast out of the box.</p>\n<p>Gatsby's rich data plugin ecosystem lets you build sites with the data you want from one or many sources: Pull data from headless CMSs (like <a href=\"https://dotcms.com\">dotCMS</a>), SaaS services, APIs (like the <a href=\"https://dotcms.com/docs/latest/content-api\">dotCMS content API</a>) and the allows you to bring the data into your page using <a href=\"https://graphql.org/\">GraphQL</a>.</p>\n<h2>Static-Site Generator Benefits</h2>\n<h3>Security</h3>\n<p>No databases and the code injection threat is close to none.</p>\n<h3>Reliability</h3>\n<p>You can serve HTML files everywhere.</p>\n<h3>Speed</h3>\n<p>Regular static sites are fast (again no database or backend) and with Gatsby + React they are even faster.</p>\n<h3>Scalability</h3>\n<p>No need for complexity on the server as static websites with HTML files can be easily scaled up by just increasing the bandwidth.</p>\n<h2>Static-Site Generator Limitations</h2>\n<p>Fetching data for a Gatsby site happens at build time, meaning that if new content is created in dotCMS, it will be not available into your site until the next build, or the next time you \"run\" your static-site generator CMS which is Gatsby in today's case.</p>\n<h3>But... There Are Solutions for This Too</h3>\n<ol>\n<li>You can create a cronjob that runs every <em>n</em> minutes to build and deploy your site.</li>\n<li><a href=\"https://www.gatsbyjs.org/docs/building-apps-with-gatsby/#hybrid-app-pages\">Hybrid app pages</a> to the rescue! Remember Gatsby have React.js in his core which means you can make network request to APIs and get new data into your components.</li>\n</ol>\n<h2>How to Create a Gatsby Site</h2>\n<h3>Install Gatsby</h3>\n<p>Gatsby have this amazing CLI tool to create, manage and run Gatsby projects, to install it, go to your terminal and run:</p>\n<pre><code class=\"language-bash\">$ npm install --global gatsby-cli\n</code></pre>\n<p>If everything went well, you can type:</p>\n<pre><code class=\"language-bash\">$ gatsby -v\n</code></pre>\n<p>And get 2.4.3 or a similar version:</p>\n<p><img src=\"https://picsum.photos/1920/1080\" alt=\"gatsby install\"></p>\n<h2>Create a Gatsby Site</h2>\n<p>Now let's use the Gatsby CLI tool to create a site:</p>\n<pre><code class=\"language-bash\">$ gatsby new dotcms-site\n</code></pre>\n<p>Note: You can replace \"dotcms-site\" with the name you want for your project.</p>\n<h3>The command you just ran:</h3>\n<ol>\n<li>Created a new site with the Gatsby default starter.</li>\n<li>Created a folder with the name of the project (dotcms-site).</li>\n<li>Install all the npm packages that needs to run the site.</li>\n<li>Made your life easier!</li>\n</ol>\n<h3>Let's Run Our New Gatsby Site:</h3>\n<pre><code class=\"language-bash\">$ cd dotcms-site\n</code></pre>\n<p>Browse into the folder of your project.</p>\n<pre><code class=\"language-bash\">$ gatsby develop\n</code></pre>\n<p>This command starts a development server. You will be able to see and interact with your new site in a development environment. Also, it has live reload, so any changes you do in your files you can see immediately in your site.</p>\n<p>Now open a browser and go to <em><a href=\"http://localhost:8000\">http://localhost:8000</a></em> and if everything went well you should something like:</p>\n<p><img src=\"./gatsby-starter-site-hi-people.png\" alt=\"Gatsby Hello World\"></p>\n<h2>To Get Data, You Need a Source Plugin</h2>\n<p>Gatsby has a plugin system, in order to get data you need what they call a \"Source Plugin.\" Source plugins \"source\" data from remote or local locations into what Gatsby calls <a href=\"https://www.gatsbyjs.org/docs/node-interface/\">nodes</a>.</p>\n<p>Think of a node as the exact equivalent of a <a href=\"https://dotcms.com/docs/latest/content\">contentlet in dotCMS</a>. So if you are showing products, every product object you pull from your headless CMS is a Gatsby node.</p>\n<p>You're going to write a Gatsby source plugin that fetches all the contentlets in a dotCMS instance and turns them into Gatsby nodes that you can later display in our pages by querying with GraphQL.</p>\n<p><img src=\"./gatsby-blog-graphic.png\" alt=\"dotCMS to Gatsby Page Diagram\"></p>\n<p>Before you start, if you would like to read more about Gatsby Source plugin their <a href=\"https://www.gatsbyjs.org/docs/create-source-plugin/\">documentation</a> and <a href=\"https://www.gatsbyjs.org/docs/source-plugin-tutorial/\">tutorial</a> are really good.</p>\n<h3>Create gatsby-source-dotcms Plugin</h3>\n<p>The bare essentials of a plugin are: directory named after your plugin, which contains a package.json file and a gatsby-node.js file:</p>\n<pre><code>|-- plugins\n|-- gatsby-source-dotcms\n    |-- gatsby-node.js\n        |-- package.json\n</code></pre>\n<p>Start by creating the directory and changing into it:</p>\n<pre><code class=\"language-bash\">$ mkdir plugins\n$ mkdir plugins/gatsby-source-dotcms\n$ cd plugins/gatsby-source-dotcms\n</code></pre>\n<h4>Create a package.json File</h4>\n<p>Now create a package.json file. This describes your plugin and any third-party code it might depend on. npm has a command to create this file for you. Run</p>\n<pre><code class=\"language-bash\">$ npm init --yes\n</code></pre>\n<p>to create the file using default options.</p>\n<p>NOTE: You can omit <code>--yes</code> if you'd like to specify the options yourself.</p>\n<p>With the set up done, move on to adding the plugin's functionality.</p>\n<h4>Create a gatsby-node.js File</h4>\n<p>Create a new file called gatsby-node.js in your gatsby-source-dotcms directory. Open the file in your favorite code editor and add the following:</p>\n<pre><code class=\"language-javascript\">exports.sourceNodes = (\n  { actions, createNodeId, createContentDigest },\n  configOptions\n) => {\n  const { createNode } = actions\n  // Gatsby adds a configOption that's not needed for this plugin, delete it\n  delete configOptions.plugins\n\n  // plugin code goes here...\n  console.log(\"Testing my DotCMS plugin\", configOptions)\n}\n</code></pre>\n<h4>What Did You Do by Adding This Code?</h4>\n<p>You implemented Gatsby's sourceNodes API which Gatsby will run as part of its bootstrap process. When Gatsby calls sourceNodes, it'll pass in some helper functions (actions, createNodeId, and createContentDigest) along with any config options that are provided in your project's <code>gatsby-config.js</code> file:</p>\n<pre><code class=\"language-javascript\">exports.sourceNodes = ({ actions, createNodeId, createContentDigest }, configOptions) => {...}\n</code></pre>\n<p>You do some initial setup:</p>\n<pre><code class=\"language-javascript\">const { createNode } = actions\n\n// Gatsby adds a configOption that's not needed for this plugin, delete it\ndelete configOptions.plugins\n</code></pre>\n<p>And finally add a placeholder message:</p>\n<pre><code class=\"language-javascript\">console.log(\"Testing my DotCMS plugin\", configOptions)\n</code></pre>\n<h2>How to Add the dotCMS Plugin to Your Gatsby Site</h2>\n<p>The skeleton of your plugin is in place, which means you can add it to your project and check your progress so far.</p>\n<p>Open <code>gatsby-config.js</code> from the root directory of your tutorial site, and add the gatsby-source-dotcms plugin:</p>\n<pre><code class=\"language-javascript\">module.exports = {\n  siteMetadata: {\n    title: \"Gatsby Default Starter\",\n  },\n\n  plugins: [\n    {\n      resolve: \"gatsby-source-dotcms\",\n      options: {},\n    },\n  ],\n}\n</code></pre>\n<p>Open a new terminal in the root directory of your tutorial site, then start Gatsby's development mode:</p>\n<pre><code class=\"language-bash\">$ gatsby develop\n</code></pre>\n<p>Check the lines after success on PreBootstrap; you should see your \"Testing my plugin\" message along with an empty object from the options your <code>gatsby-config.js</code> file:</p>\n<p><img src=\"./testing-my-plugin.png\" alt=\"Gatsby and dotCMS Plugin Node\"></p>\n<p>Note that Gatsby is warning you that your plugin is not generating any Gatsby nodes. Time to fix that.</p>\n<h3>Getting the Data From DotCMS</h3>\n<p>Like I mentioned before, you need to get ALL the contentlets from the dotCMS instance and turn them into Gatsby nodes.</p>\n<h4>The Action Plan</h4>\n<p>In order to create a GraphQL node that you can query by content type, you need two things from dotCMS:</p>\n<ol>\n<li>The contentlet.</li>\n<li>The content type of each contentlet.</li>\n</ol>\n<p>In <a href=\"https://dotcms.com/\">dotCMS</a>, you need to use the new <a href=\"https://dotcms.com/docs/latest/content-type-api\">content types REST endpoint</a> to get all the content types variables and then use the Content API endpoint to get all the contentlets for each content type in the instance.</p>\n<p>You'll combine the results from the two requests together to create a big collection of contentlets with an extra property of contentType.</p>\n<h4>Add Dependencies</h4>\n<p>From your plugin folder (/plugins/gatsby-source-dotcms) run:</p>\n<pre><code class=\"language-bash\">$ npm install node-fetch --save\n</code></pre>\n<p>Open your package.json file and you'll see node-fetch have been added to a dependencies section at the end:</p>\n<pre><code class=\"language-json\">\"dependencies\": {\n    \"node-fetch\": \"^2.2.0\"\n}\n</code></pre>\n<p><a href=\"https://github.com/bitinn/node-fetch\">node-fetch</a> is a light-weight module that brings <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\">window.fetch</a> to Node.js so you can use fetch to do the request to dotCMS endpoints.</p>\n<h4>Create a dotCMS JavaScript Library</h4>\n<p>To create the dotCMS library to get all the contentlets and content types you going to use:</p>\n<ol>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes\">ES6 Classes</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function\">Async</a>/<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await\">Await</a></li>\n</ol>\n<p>I'm assuming that you are familiar with these technologies, so I'm not going to explain how they work in this tutorial in too much detail.</p>\n<p>To begin, create a dotcms-api.js file inside the /plugins/gatsby-source-dotcms folder, open the file, and add the following code:</p>\n<pre><code class=\"language-javascript\">const fetch = require(\"node-fetch\")\n\nclass DotCMSApi {\n  constructor(options) {\n    this.options = options\n  }\n\n  getBaseUrl() {\n    return `${this.options.host.protocol}://${this.options.host.url}`\n  }\n\n  getContentletsByContentType(contentType) {\n    const getUrl = () => {\n      return `${this.getBaseUrl()}/api/content/render/false/query/+contentType:${contentType}%20+(conhost:${\n        this.options.host.identifier\n      }%20conhost:SYSTEM_HOST)%20+languageId:1%20+deleted:false%20+working:true/orderby/modDate%20desc`\n    }\n\n    return fetch(getUrl())\n      .then(data => data.json())\n      .then(data => data.contentlets)\n      .then(contentlets => {\n        contentlets.forEach(contentlet => {\n          contentlet.contentType = contentType\n        })\n        return contentlets\n      })\n  }\n\n  async getContentTypesVariables() {\n    const getUrl = () => {\n      return `${this.getBaseUrl()}/api/v1/contenttype?per_page=100`\n    }\n\n    return fetch(getUrl(), {\n      headers: {\n        DOTAUTH: Buffer.from(\n          `${this.options.credentials.email}:${this.options.credentials.password}`\n        ).toString(\"base64\"),\n      },\n    })\n      .then(data => data.json())\n      .then(contentTypes =>\n        contentTypes.entity.map(contentType => contentType.variable)\n      )\n  }\n\n  async getData() {\n    const contentlets = await this.getContentTypesVariables().then(\n      variables => {\n        return variables.map(async variable => {\n          const data = await this.getContentletsByContentType(variable)\n          return data\n        })\n      }\n    )\n    return Promise.all(contentlets)\n  }\n}\n\nexports.getContentlets = async configOptions => {\n  const dotCMSApi = new DotCMSApi(configOptions)\n\n  return dotCMSApi.getData().then(contentTypesContentlets => {\n    // Flatten nested array\n    return [].concat.apply([], contentTypesContentlets)\n  })\n}\n</code></pre>\n<h4>What is all this code doing?</h4>\n<pre><code class=\"language-javascript\">const fetch = require(\"node-fetch\")\n</code></pre>\n<p>You imported the npm module, node-fetch, and it will be used to do the requests to the dotCMS instance and get the data you need.</p>\n<pre><code class=\"language-javascript\">class DotCMSLibrary {\n  constructor(options) {\n    this.options = options\n  }\n}\n</code></pre>\n<p>Then you created a class that contains the methods you use to get the data you need (contentlets and content types). When you create an instance of this class you pass the options that you'll add to the <code>gatsby-config.js</code> file.</p>\n<pre><code class=\"language-javascript\">getBaseUrl() {\n    return `${this.options.host.protocol}://${this.options.host.url}`\n}\n</code></pre>\n<p>These simple methods are use to get the dotCMS instance URL.</p>\n<pre><code class=\"language-javascript\">getContentletsByContentType(contentType) {\n    const getUrl = () => {\n        return `${this.getBaseUrl()}/api/content/render/false/query/+contentType:${contentType}%20+(conhost:${this.options.host.identifier}%20conhost:SYSTEM_HOST)%20+languageId:1%20+deleted:false%20+working:true/orderby/modDate%20desc`;\n    };\n\n    return fetch(getUrl())\n        .then((data) => data.json())\n        .then((data) => data.contentlets)\n        .then((contentlets) => {\n            contentlets.forEach((contentlet) => {\n                contentlet.contentType = contentType;\n            });\n            return contentlets;\n        });\n}\n</code></pre>\n<p>In this method, you do the request to get all the contentlets of the specific content type you'll pass as a parameter, and to each contentlet you add the <code>contentType</code> property that will be used to query data. This method is called several times, once for each content type in the dotCMS instance.</p>\n<pre><code class=\"language-javascript\">async getContentTypesVariables() {\n    const getUrl = () => {\n        return `${this.getBaseUrl()}/api/v1/contenttype?per_page=100`;\n    };\n\n    return fetch(getUrl(), {\n        headers: {\n            DOTAUTH: Buffer.from(\n                `${this.options.credentials.email}:${this.options.credentials.password}`\n            ).toString('base64')\n        }\n    })\n        .then((data) => data.json())\n        .then((contentTypes) => contentTypes.entity.map((contentType) => contentType.variable));\n}\n</code></pre>\n<p>This method will get an array of content type variables using the new Content Types API and then map the result to an array of variables.</p>\n<p>NOTE: make sure you pass the query param per_page=100 at the URL with the full amount (or more) of content types in your instance.</p>\n<pre><code class=\"language-javascript\">async getData() {\n    const contentlets = await this.getContentTypesVariables().then((variables) => {\n        return variables.map(async (variable) => {\n            const data = await this.getContentletsByContentType(variable);\n            return data;\n        });\n    });\n    return Promise.all(contentlets);\n}\n</code></pre>\n<p>And finally you used <code>getContentTypesVariables</code> and <code>getContentletsByContentType</code> to get all the contentlets in the dotCMS instance. First, you get an array of content types variables and for each one of them you do a request to the dotCMS Content API to get the all contentlets for each content type. Remember that this code runs on build time which means it not going to be a performance issue doing so many requests.</p>\n<p>The constant contentlets results in an array of Promises of contentlets so you have to use <code>Promise.all</code> to return a single Promise that resolves when all of the contentlet promises have resolved.</p>\n<pre><code class=\"language-javascript\">exports.getContentlets = async configOptions => {\n  const dotCMSApi = new DotCMSApi(configOptions)\n\n  return dotCMSApi.getData().then(contentTypesContentlets => {\n    // Flatten nested array\n    return [].concat.apply([], contentTypesContentlets)\n  })\n}\n</code></pre>\n<p>Finally, you export one method from this library, where you initialize the DotCMS API with the config options from the <code>gatsby-config.js</code> file get all the contentlets in the dotCMS instance and flatten it into one big collection of contentlets with an extra property of content type. The result will be like:</p>\n<pre><code class=\"language-json\">[\n    {\n        \"contentType\": \"newsItem\",\n        \"owner\": \"dotcms.org.1\",\n        \"identifier\": \"f60ed48b-1f5f-4a7b-b4b0-f5a857b41e6a\",\n        \"inode\": \"734944ff-6f02-4337-b9fe-aef3c372dad8\",\n        \"title\": \"This is a new item\",\n        \"expire\": \"2020-01-02 02:19:00.0\",\n        \"tags\": \"oil,investment,gas,prices,retiree:persona\"\n    },\n    {...}\n]\n</code></pre>\n<p>The appended <code>contentType</code> property in this collection of contentlets is key, because we'll be using that to do our GraphQL queries.</p>","frontmatter":{"date":"March 09, 2019","path":"/blog/my-third-post","title":"Building a Website With Gatsby and a Headless CMS - Part 3","description":"This article will walk you through the process of using Gatsby alongside a headless CMS. This article will walk you through the process of using Gatsby alongside a headless CMS.This article will walk you through the process.."}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}